# 3장 리터럴과 생성자
자바스크립트의 리터럴 표기법 패턴을 사용하면 좀 더 정확하고 표현력이 풍부하면서도 에러율이 낮은 방식으로 객체를 정의할 수 있다.

## 3.1 객체 리터럴

```js
// 빈 객체에서 시작한다.
var dog = {};

// 프로퍼티 하나를 추가한다.
dog.name = "Benji";

// 이번에는 메서드를 추가한다.
dog.getName = function(){
    return dog.name;
}
```

이 코드는 백지와도 같은 빈 객체에서 시작한다. 그리고 나서 프로퍼티와 메서드를 추가한다. 프로그램 생명주기 중 어느때라도 다음과 같은 일을 할 수 있다.

- 프로퍼티와 메서드 값을 변경할 수 있다.
```js
dog.getName = function(){
    // 메서드가 하드코딩된 값을 반환하도록 재정의.
    return 'Frido';
}
```

- 프로퍼티나 메서드를 완전히 삭제한다.
```js
delete dog.name;
```

- 다른 프로퍼티나 메서드를 추가한다.
```js
dog.say = function(){
    return "Woof!";
}

dog.living = true;
```

반드시 빈 객체에서 시작해야 하는 것은 아니다.

```js
var dog = {
    name: "Benji",
    getName: function(){
        return this.name;
    }
}
```


### 객체 리터럴 문법
문법규칙
- 객체를 중괄호({와})로 감싼다.
- 객체 내의 프로퍼티와 메서드를 쉼표(,)로 분리한다. 마지막 이름-값 쌍 뒤에 쉼표가 들어가면 **IE에서는 에러가 발생**하므로 마지막에는 사용하지 말아야 한다.
- 프로퍼티명과 프로퍼티 값은 콜론(:)으로 분리한다.
- 객체를 변수에 할당할 때는 닫는 중괄호 뒤에 세미콜론(;)을 빼먹지 않도록 한다.

### 생성자 함수로 객체 생성하기
객체를 생성할 때는 직접 만든 생성자 함수를 사용할 수도 있고, ``Object()``, ``Date()``, ``String()``등 내장 생성자를 사용할 수도 있다. 다음 예제는 동일한 객체를 생성하는 두 가지 방법을 보여준다.

```js
// 첫번째 방법 - 리터럴 사용
var car = {goes:'far'}

// 다른 방법 - 내장 생성자 사용
// 경고: 이 방법은 안티패턴이다.
var car = new Object();
car.goes = 'far';
```

- 리터럴 표기법의 명백한 이점은 더 짧다는 것.
- 리터럴 표기법을 사용하면 유효범위 판별 작업이 발생하지 않는다.

### 객체 생성자의 함정
Object() 생성자의 문제되는 기능은 **인자를 받을 수 있다는 점**이다. 인자로 전달되는 값에 따라 생성자 함수가 다른 내장 생성자에 객체 생성을 위임할 수 있고, 따라서 기대한 것과는 다른 객체가 반환되기도 한다.

```js
// 경고: 모두 안티패턴이다.

// 빈 객체
var o = new Object();
console.log(o.constructor === Object);  // true

// 숫자 객체
var o = new Object(1);
console.log(o.constructor === Object);  // false
console.log(o.constructor === Number);  // true
console.log(o.toFixed(2));  // "1.00"   // 소수점 2번째 자리에서 반올림

// 문자열 객체
var o = new Object("I am a string");
console.log(o.constructor === Object);  // false
console.log(o.constructor === String);  // true
console.log(typeof o.substring);  // "function"

// 불린 객체
var o = new Object(true);
console.log(o.constructor === Object);  // false.
console.log(o.constructor === Boolean);  // true
```

``Object()``생성자는 이같은 동작방식 대문에, 런타임에 결정하는 동적인 값이 생성자에 인자로 전달될 경우 예기치 않은 결과가 반환될 수 있다.
**결론적으로, ``new Object()``를 사용하지 마라.** 더 간단하고 안정적인 객체 리터럴을 사용하라.